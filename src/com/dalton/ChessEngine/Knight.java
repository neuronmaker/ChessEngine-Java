package com.dalton.ChessEngine;

import java.util.ArrayList;

import static com.dalton.ChessEngine.Types.*;

/**
 * Class for the Knight piece
 * @author Dalton Herrewynen
 * @version 4
 * @see Piece
 */
public class Knight extends Piece{
	/** All the offsets that the Knight can move too */
	private static final int[][] offset={//0 is x, 1 is y
			{-2,1},{-1,2},{-2,-1},{-1,-2},//left half
			{2,1},{1,2},{2,-1},{1,-2}};   //right half
	/** Attacking square mask for Knight */
	private static final long[] attackMask={
			0b0000000000000000000000000000000000000000000000100000010000000000L,
			0b0000000000000000000000000000000000000000000001010000100000000000L,
			0b0000000000000000000000000000000000000000000010100001000100000000L,
			0b0000000000000000000000000000000000000000000101000010001000000000L,
			0b0000000000000000000000000000000000000000001010000100010000000000L,
			0b0000000000000000000000000000000000000000010100001000100000000000L,
			0b0000000000000000000000000000000000000000101000000001000000000000L,
			0b0000000000000000000000000000000000000000010000000010000000000000L,
			0b0000000000000000000000000000000000000010000001000000000000000100L,
			0b0000000000000000000000000000000000000101000010000000000000001000L,
			0b0000000000000000000000000000000000001010000100010000000000010001L,
			0b0000000000000000000000000000000000010100001000100000000000100010L,
			0b0000000000000000000000000000000000101000010001000000000001000100L,
			0b0000000000000000000000000000000001010000100010000000000010001000L,
			0b0000000000000000000000000000000010100000000100000000000000010000L,
			0b0000000000000000000000000000000001000000001000000000000000100000L,
			0b0000000000000000000000000000001000000100000000000000010000000010L,
			0b0000000000000000000000000000010100001000000000000000100000000101L,
			0b0000000000000000000000000000101000010001000000000001000100001010L,
			0b0000000000000000000000000001010000100010000000000010001000010100L,
			0b0000000000000000000000000010100001000100000000000100010000101000L,
			0b0000000000000000000000000101000010001000000000001000100001010000L,
			0b0000000000000000000000001010000000010000000000000001000010100000L,
			0b0000000000000000000000000100000000100000000000000010000001000000L,
			0b0000000000000000000000100000010000000000000001000000001000000000L,
			0b0000000000000000000001010000100000000000000010000000010100000000L,
			0b0000000000000000000010100001000100000000000100010000101000000000L,
			0b0000000000000000000101000010001000000000001000100001010000000000L,
			0b0000000000000000001010000100010000000000010001000010100000000000L,
			0b0000000000000000010100001000100000000000100010000101000000000000L,
			0b0000000000000000101000000001000000000000000100001010000000000000L,
			0b0000000000000000010000000010000000000000001000000100000000000000L,
			0b0000000000000010000001000000000000000100000000100000000000000000L,
			0b0000000000000101000010000000000000001000000001010000000000000000L,
			0b0000000000001010000100010000000000010001000010100000000000000000L,
			0b0000000000010100001000100000000000100010000101000000000000000000L,
			0b0000000000101000010001000000000001000100001010000000000000000000L,
			0b0000000001010000100010000000000010001000010100000000000000000000L,
			0b0000000010100000000100000000000000010000101000000000000000000000L,
			0b0000000001000000001000000000000000100000010000000000000000000000L,
			0b0000001000000100000000000000010000000010000000000000000000000000L,
			0b0000010100001000000000000000100000000101000000000000000000000000L,
			0b0000101000010001000000000001000100001010000000000000000000000000L,
			0b0001010000100010000000000010001000010100000000000000000000000000L,
			0b0010100001000100000000000100010000101000000000000000000000000000L,
			0b0101000010001000000000001000100001010000000000000000000000000000L,
			0b1010000000010000000000000001000010100000000000000000000000000000L,
			0b0100000000100000000000000010000001000000000000000000000000000000L,
			0b0000010000000000000001000000001000000000000000000000000000000000L,
			0b0000100000000000000010000000010100000000000000000000000000000000L,
			0b0001000100000000000100010000101000000000000000000000000000000000L,
			0b0010001000000000001000100001010000000000000000000000000000000000L,
			0b0100010000000000010001000010100000000000000000000000000000000000L,
			0b1000100000000000100010000101000000000000000000000000000000000000L,
			0b0001000000000000000100001010000000000000000000000000000000000000L,
			0b0010000000000000001000000100000000000000000000000000000000000000L,
			0b0000000000000100000000100000000000000000000000000000000000000000L,
			0b0000000000001000000001010000000000000000000000000000000000000000L,
			0b0000000000010001000010100000000000000000000000000000000000000000L,
			0b0000000000100010000101000000000000000000000000000000000000000000L,
			0b0000000001000100001010000000000000000000000000000000000000000000L,
			0b0000000010001000010100000000000000000000000000000000000000000000L,
			0b0000000000010000101000000000000000000000000000000000000000000000L,
			0b0000000000100000010000000000000000000000000000000000000000000000L,};

	/**
	 * Only constructor requires the setting of team (color)
	 * @param team which side is this piece going to be on
	 */
	public Knight(boolean team){
		super((team==WHITE)? PieceCode.KnightW : PieceCode.KnightB);
	}

	/**
	 * Converts the Knight to a human-readable String containing its internal state
	 * @return String representation of internal state
	 */
	@Override
	public String toString(){
		return PieceCode.decodeTeamString(pieceCode)+" Knight";
	}

	/**
	 * Calculates the Knight's value to the AI player
	 * @param enemies  The positions of all enemies in a bitmask
	 * @param blanks   The position of all blank squares in a bitmask
	 * @param position Where this Piece is located on the board
	 * @return relative value to the AI
	 */
	@Override
	public int pieceValue(final long enemies,final long blanks,final int position){
		int score=300;
		final int[] scoreLUT={
				75,50,50,50,50,50,50,75,//score table is subject to change and tweaks
				50,50,50,50,50,50,50,50,
				50,50,10, 0, 0,10,50,50,
				50,50, 0, 0, 0, 0,50,50,
				50,50, 0, 0, 0, 0,50,50,
				50,50,10, 0, 0,10,50,50,
				50,50,50,50,50,50,50,50,
				75,50,50,50,50,50,50,75,
		};
		return score-scoreLUT[position];
	}

	/**
	 * The move generator method for Knight
	 * @param moves    Reference to the Move list
	 * @param enemies  The positions of all enemies in a bitmask
	 * @param blanks   The position of all blank squares in a bitmask
	 * @param position The position index to check from
	 */
	@Override
	public void getMoves(ArrayList<Integer> moves,final long enemies,final long blanks,final int position){
		//Check each direction
		for(int[] dir: offset){
			int destIndex=Coord.shiftIndex(position,dir[0],dir[1]);
			if(!Coord.isShiftValid(position,dir[0],dir[1])) continue;//We can only move the knight to squares that exist
			if(0!=(blanks & (1L << destIndex))) moves.add(Move.encodeNormal(this.pieceCode,position,destIndex));//if blank, then just move
			else if(0!=(enemies & (1L << destIndex))) moves.add(Move.encode(Move.capture,this.pieceCode,position,destIndex));//Only capture the other team
		}
	}

	/**
	 * Get the mask of squares the Knight can attack
	 * @param enemies Mask of enemies to capture
	 * @param blanks  Mask of blank squares
	 * @param pos     The integer position index
	 * @return a 64-bit integer bit mask
	 */
	@Override
	public long attackMask(final long enemies,final long blanks,final int pos){
		return attackMask[pos]&(blanks|enemies);//take attacking mask and only attack pieces that are blank or enemies
	}
}